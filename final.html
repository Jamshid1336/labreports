<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- --> 
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">



  <header>
    <h1>Fractal Geometry Final Project Lab Report</h1>
    <p class="author">
      [Jay Michaels] <br />
      [April 27th 2025]
  </header>
</body>


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>The Sierpinski Triangle </h2>
        <p>
        This Sierpinski Triangle is generated using the Chaos Game. The Chaos Game takes a vertex and a random 
	nearby or interior point, a random vertex of the equilateral triangle, and finds the midpoint of the two. 
	The midpoint becomes "current point". Next a vertex is selected randomly again, and the midpoint between 
	that vertex and "current point" is found, and becomes the new "current point". In this scenario, it forms 
	the Sierpinski Triangle. This can be changed in certain ways to make different fractal patterns with 
	other regular polygons.	
        </p>
	<p>
	The code makes the three vertices of the equilateral triangle near the top. Then near the bottom where the 
	plotting commands are, there is plt.axis('equal'). This makes the x and y axis of the canvas the same scale.
	If the triangle is made to be narrower while staying the same height, the 'equal' will show it that way. 
	If the equal command is removed, then the x and y axis skew the narrow triangle to be isosceles again. 
	The k = randint(0, 2) is the random selection of one of the three vertices
	</p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

	import matplotlib.pyplot as plt
from random import random, randint
import numpy as np

def midpoint(P, Q):
    return ((1/3)*(P[0] + Q[0]), (2/3)*(P[1] + Q[1]))

vertices = [(0, 0), (4, 2*np.sqrt(3)), (8, 0)]
iterates = 100000
x, y = [0]*iterates, [0]*iterates
x[0], y[0] = random(), random()

for i in range(1, iterates):

    k = randint(0, 2)

    x[i], y[i] = midpoint( vertices[k], (x[i-1], y[i-1]) )

plt.figure(figsize=(8, 8))
plt.scatter(x, y, color = 'purple', s=5)
plt.title('Sierpinski Triangle Generated Using the Chaos Game')
plt.axis('equal')  # Ensure aspect ratio is equal for an equilateral triangle
plt.show()


	</code></pre>

      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
        By changing finding the midpoint (0.5) to finding other distances between a vertex and a "current point", 
	parts of the Sierpinski Triangle disappear, such as the one below.
        </p>


	        <figure>
          <img
            src="onethird.png"
            alt="onethird"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            changed from 0.5 and 0.5 to 1/3 and 1/3
          </figcaption>
        </figure>

	      
      </section>

 <h2>Barnsley Fern</h2>
        <p>
        This Barnsley Fern is a fractal generated from four functions, f1, f2, f3, and f4. Each function is 
	responsible for a piece of the fern, such as the stem, left leaves, and right leaves. By changing the 
	coefficients of the previous x and y values that make the new x and y values, the stem can be made to 
	look disjointed, the leaves can be made to be more full or more sparse, and can be twisted and curled 
	around the stem also. Editing the coefficients of y in f3 and f4 changes the twisting of the leaves.
	Changing the coefficient of the x in the new x and the y in the new y changes the overall fullness and 
	curvature of the plant.
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

	def f1(x, y):
    x = 0
    y = 0.16 * y
    return x, y

def f2(x, y):
    x_new = 0.99 * x + 0.04 * y
    y_new = -0.04 * x + 0.99 * y + 1.6
    return x_new, y_new

def f3(x, y):
    x_new = 0.9 * x - 0.5 * y
    y_new = 0.23 * x + 0.5 * y + 1.6
    return x_new, y_new

def f4(x, y):
    x_new = -0.9 * x + 0.5 * y
    y_new = 0.26 * x + 0.5 * y + 0.44
    return x_new, y_new

# Probabilities for each function
probabilities = [0.01, 0.85, 0.07, 0.07].
		
	</code></pre>


</section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
        Originally I did not change the probabilities of each function being used. What they do is change the chance 
	that the function will happen, so having more probability on f2 makes a strong stem, while f3 and f2 makes 
	the leaves to the side. If the probability of f3 and f4 is raised and the f2 probability is lowered, then there 
	are more leaves and the stem loses its bulk. These images show the results of changes to the functions and to 
	the probabilities.
        </p>


        <figure>
          <img
            src="xmas tree.png"
            alt="xmas tree"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Christmas Tree
          </figcaption>
        </figure>

        <figure>
          <img
            src="peacock.png"
            alt="peacock"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Peacock
          </figcaption>
        </figure>

	      
        <figure>
          <img
            src="twisted.png"
            alt="peacock"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Twisted Tree
          </figcaption>
        </figure>
      </section>

	      
        <figure>
          <img
            src="sparse.png"
            alt="sparse"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Sparse Tree
          </figcaption>
        </figure>
      </section>
 <h2>L-Systems</h2>
        <p>
        L-system stands for Lindenmayer System. This is a method of making complex images using simple rules. 
	In this case, the code looks at a string of characters and symbols one piece at a time. F moves forward,
	+ turns left, and - turns right. A string might look like F+F+F-FF-F. That would move forward, left, forward, 
	left again, forward and then right, forward twice, another right, and another forward. The string is called 
	an axiom.
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

def draw_lsystem(turtle_string, length, angle):
    stack = []
    for command in turtle_string:
        if command == 'F':
            forward(length)
        elif command == '+':
            left(angle)
        elif command == '-':
            right(angle)
        elif command == '[':
            position = (getx(), gety())
            heading_angle = heading()
            stack.append((position, heading_angle))
        elif command == ']':
            position, heading_angle = stack.pop()
            jump(position[0], position[1])
            face(heading_angle)

# Define the L-system rules
rules = {'F': 'FF-[-F+F+F-F-F]+[+F+F-F+F]'}

		
	</code></pre>


</section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
        In the code I did not change what the symbols did, but I did change the rule several times to make different images. 
	larger angles turned made more visibly polygon shaped designs, while smaller angles turned made more a thinner image. 
	Also, by alternating lefts and rights, the fractal could be made to have a wavy look instead of sharp turns.
        </p>




        <figure>
          <img
            src="turns.png"
            alt="turns"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Wavier Fronds
          </figcaption>
        </figure>


        <figure>
          <img
            src="both sides.png"
            alt="both sides"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Lefts and Rights changed to balance both sides
          </figcaption>
        </figure>



      </section>


   <h2>Hilbert Curves</h2>
        <p>
         This Hilbert Curve creates what looks like a square labyrinth. The labyrinth is build by having axioms 
	inside other axioms. F is still the character the code is looking for, but now L and R also are a part of 
	the rules. F is forward, + is left, - is right. L is a new rule that has more Ls, Fs, and Rs in it. R is 
	also a new rule that has Ls and Fs and Rs in it. Every time the code sees a character, it evaluates whether 
	to move forward, to turn, or to replace the character with a new string of directions. This causes the iterations 
	that make the structure of the pattern.
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

axiom = 'L'
rules = {
    'L': 'FFRFFRFFR', #-RF+LFL+FR-
    'R': '+F+F--F+F--F+F--F+F+F' #+LF-RFR-FL+
}
iterations = 8  # Adjust the iterations to change the order (e.g., 1 to 5)
angle = 60
		
	</code></pre>


</section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
        It is somewhat brute force, but I managed to make a small version of a Koch Snowflake-like pattern.
        </p>




        <figure>
          <img
            src="t.koch.png"
            alt="t.koch"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            A sort of Koch Pattern
          </figcaption>
        </figure>


      </section>z
      
      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">


      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
        conclusion here
        </p>
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
